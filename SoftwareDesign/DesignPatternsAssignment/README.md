IDEAS:
- Use Lazy Loading on Client
- Use Visitor Pattern for ContactHandler
- Make Report implement Comparable?
- Probably use Bridge pattern for Orders
- The only pattern I know to reduce RAM is flyweight, but I am not sure how to do that for Reports.
Does LazyLoading reduce RAM? I don't think LazyLoading is correct because the data will be loaded as soon
as the report is compared. I also need to understand better why reports are being compared.


1. Problem: Too much RAM from Reports
- Flyweight? But how...
2. So many types of orders
- Bridge..?
3. Contact Handling
- Visitor? I don't think this is the right pattern because there aren't different types of visitors, just locations (Contact Methods)
- Strategy? This pattern makes the most sense, but I'm confused that the Concrete Strategy is basically the classes in the contact package. We cannot
edit the contact pacakge, so I don't know how to implement the Strategy pattern without creating redundant classes.
4. Loading Clients from DB takes a long time
- Lazy Loading
- I implemented Lazy Loading on the ClientImpl class by creating a map that tracks if a field has been loaded (true/false).
The constructor doesn't make any calls to the database. The database is called if a field is requested and it has not been loaded yet.
One concern: I am storing the AuthToken in the Client class. I don't know if this breaks any authentication issues. It is needed to call the database in
the get() methods when a field hasn't been loaded yet.

5. Compare Equality of Reports without primary key
Implement Comparable? Value Object?
6. Order Creation process has lots of lag
Unit Of Work
7.Multithreading

